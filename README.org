#+TITLE: Emacs + eVilish (modalka) + Org (EVO)
#+AUTHOR: Jack Henahan
| *Author* | Jack Henahan <jhenahan@me.com> |
|----------+--------------------------------|
| *Date*   | 2017-07-16 18:18:32            |

This file is updated every time the init file is reloaded, so the
entire configuration (aside from the bootstrapping code) should
document itself here. If you don't often reload Emacs, you can update
the documentation with =M-x reload-user-init-file=.

#+NAME: Note
#+BEGIN_SRC emacs-lisp
  ;;; ------------------------------------------
  ;;; Do not edit this file. It was tangled from
  ;;; an org file.
  ;;; ------------------------------------------
  (provide 'evo)
#+END_SRC

* Emacs Configuration in an Org file
I've declared Emacs config bankruptcy (again!). In the interest of a
wacky refresh, might as well just start from scratch. =req-package=,
=Cask=, and =pallet= don't quite fit my needs, anymore, so this'll
be a fairly straightforward =quelpa= and =use-package= affair.

* Keep Custom Out of Version Control
#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+END_SRC

* Package Management

** Initialize Quelpa (auto-upgrade snippet)
#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (if (require 'quelpa nil t)
      (quelpa-self-upgrade)
    (with-temp-buffer
      (url-insert-file-contents "https://raw.github.com/quelpa/quelpa/master/bootstrap.el")
      (eval-buffer)))
#+END_SRC

** Install =quelpa-use-package=
#+BEGIN_SRC emacs-lisp
  (quelpa
   '(quelpa-use-package
     :fetcher github
     :repo "quelpa/quelpa-use-package"))
  (require 'quelpa-use-package)
#+END_SRC

** Load =use-package
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (use-package use-package
      :quelpa
      (use-package
        :fetcher github
        :repo "jwiegley/use-package")))
  
  (use-package diminish
    :quelpa
    (diminish
     :fetcher github
     :repo "myrjola/diminish.el"))
  (require 'bind-key)
#+END_SRC

* Core Configuration
** Who are you?
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Jack Henahan")
#+END_SRC
** Improvements
First, I need to undo a series of exceptionally terrible defaults
that Emacs insists upon, and set up basic ergonomy. We'll get some
convenient modernisms set up, as well.

*** Modern Libs
Some of the default Emacs Lisp APIs are a bit unintuitive, so we're going to
use the more modern options to hopefully keep our sanity. I also include =cl=
for =lexical-let=, but I swear I'm trying to remove it.
**** Lists
#+BEGIN_SRC emacs-lisp
  (use-package dash :quelpa (:upgrade t))
#+END_SRC

**** Strings
#+BEGIN_SRC emacs-lisp
  (use-package s :quelpa (:upgrade t))
#+END_SRC

**** Files
#+BEGIN_SRC emacs-lisp
  (use-package f :quelpa (:upgrade t))
#+END_SRC
**** CL
#+BEGIN_SRC emacs-lisp
  (eval-when-compile (use-package cl))
#+END_SRC
*** System Settings
**** History
***** Backups
There's a very compelling [[https://stackoverflow.com/a/20824625/794944][SO answer]] (and accompanying [[https://www.emacswiki.org/emacs/ForceBackups][ewiki page]])
which provides a really neat and quite robust backup strategy.

First, we set up versioned backups, which will keep 10 backups,
ought to be just about enough history for anyone. You can of course
tweak this if you find you need more.

#+BEGIN_SRC emacs-lisp
  (use-package files
    :init
    (setq version-control t
          kept-new-versions 10
          kept-old-versions 0
          delete-old-versions t
          backup-by-copying t))
#+END_SRC

Emacs evidently doesn't backup version-controlled files by default,
so let's fix that. If you've never accidentally wiped all your work
between commits, we must be in different universes.

#+BEGIN_SRC emacs-lisp
  (use-package vc-hooks
    :init
    (setq vc-make-backup-files t))
#+END_SRC

Finally, we'll set up a two-pronged backup strategy -- per-save, and
per-session. First, we want to set up a directory for per-save
backups.

#+BEGIN_SRC emacs-lisp
  (use-package files
    :after f
    :commands f-join
    :config
    (let
        ((backup-directory (f-join user-emacs-directory "backup")))
      (setq backup-directory-alist
            `(("" . ,(f-join
                      backup-directory "per-save"))))))
#+END_SRC

Then, we hook into the =before-save= to save a per-session backup
(analogous to Emacs' usual backup strategy), then force a per-save
backup by unsetting =buffer-backed-up=.

#+BEGIN_SRC emacs-lisp
  (use-package files
    :after f
    :commands f-join
    :init
    (progn
      (defun force-backup-of-buffer ()
        (when (not buffer-backed-up)
          (let ((backup-directory (f-join user-emacs-directory "backup")))
            (let ((backup-directory-alist
                   `(("" . ,(f-join
                             backup-directory "per-session"))))
                  (kept-new-versions 3))
              (backup-buffer)))
          (let ((buffer-backed-up nil))
            (backup-buffer)))
  
        (add-hook 'before-save-hook 'force-backup-of-buffer))))
#+END_SRC

Finally, we don't need Emacs to generate the an auto-save list,
because I can't fathom a reason that I would want that.

#+BEGIN_SRC emacs-lisp
  (setq auto-save-list-file-prefix nil)
#+END_SRC

***** Command History
It's nice to be able to refer back to previous commands (and it's
utterly necessary for extended commands in Evil).

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :requires f
    :config
    (progn
      (let ((backup-directory (f-join user-emacs-directory "backup")))
        (setq savehist-file (f-join backup-directory "savehist")
              enable-recursive-minibuffers t
              history-length 1000
              savehist-additional-variables '(mark-ring
                                              global-mark-ring
                                              search-ring
                                              regexp-search-ring
                                              extended-command-history)
              savehist-autosave-interval 60))
      (savehist-mode t)))
#+END_SRC
**** Basic UI
***** UI Cleanup
We're trying to get away from non-keyboard inputs, entirely, so
toolbars and scroll bars have to go.

#+BEGIN_SRC emacs-lisp
  (when (functionp 'menu-bar-mode)
    (menu-bar-mode -1))
  (when (functionp 'set-scroll-bar-mode)
    (set-scroll-bar-mode 'nil))
  (when (functionp 'mouse-wheel-mode)
    (mouse-wheel-mode -1))
  (when (functionp 'tooltip-mode)
    (tooltip-mode -1))
  (when (functionp 'tool-bar-mode)
    (tool-bar-mode -1))
  (when (functionp 'blink-cursor-mode)
    (blink-cursor-mode -1))
  (setq inhibit-splash-screen t
        inhibit-startup-message t)
#+END_SRC

Also, beeps are annoying, so cut it out.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function (lambda ()))
#+END_SRC

***** Font Locking
I have never *not* wanted syntax highlighting when it's available,
so let's get that going. I don't particularly know the consequences
of forcing font-locking to handle multiline patterns, so we'll see
if that sticks around.

#+BEGIN_SRC emacs-lisp
  (use-package font-core
    :init
    (global-font-lock-mode t))
  (use-package font-lock
    :init
    (setq-default font-lock-multiline t))
#+END_SRC
**** Character Encodings
UTF-8? UTF-8. And I mean it.

#+BEGIN_SRC emacs-lisp
  (set-charset-priority 'unicode)
  (use-package mule
    :init
    (progn
      (set-default-coding-systems 'utf-8)
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (set-selection-coding-system 'utf-8)
      (prefer-coding-system 'utf-8)))
  (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+END_SRC
**** Performance Tweaks
By default, Emacs garbage collects after consing 800k bytes (not
800KB). We'll bump it up to 100MB so we don't have to do that so
much. Memory is cheap.

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold (* 100 1024 1024))
#+END_SRC

We can also set font-locking to occur in the background, which helps
when fontifying large buffers. =jit-lock-defer-time= and
=jit-lock-stealth-verbose= are =nil= by default, but it doesn't hurt
to be explicit.

#+BEGIN_SRC emacs-lisp
  (use-package jit-lock
    :init
    (setq jit-lock-defer-time nil
          jit-lock-stealth-nice 0.1
          jit-lock-stealth-time 0.2
          jit-lock-stealth-verbose nil))
#+END_SRC

This isn't strictly a performance setting, but computers have come a
long way, and I don't need Emacs complaining about a biggish
file. 25MB should be a fine limit.

#+BEGIN_SRC emacs-lisp
  (use-package files
    :init
    (setq large-file-warning-threshold (* 25 1024 1024)))
#+END_SRC
**** Security
The default for =gnutls-min-prime-bits= is 256, which might as well
be 0. Let's set something a little more future-proof.

#+BEGIN_SRC emacs-lisp
  (use-package gnutls
    :init
    (setq gnutls-min-prime-bits 4096))
#+END_SRC
**** Ergonomic Changes
One character is better than two to three.

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Hide the mouse while typing.

#+BEGIN_SRC emacs-lisp
  (setq make-pointer-invisible t)
#+END_SRC

***** Winner - window configuration history
=C-c <left>= and =C-c <right>= to move forward and backward in
window configuration history (e.g., if a function pops a buffer
with something useful, but then you need to get back to whatever
you were doing). We'll evilify this later.

#+BEGIN_SRC emacs-lisp
  (use-package winner
    :defer t)
#+END_SRC
**** Undoing Weird Emacs Defaults
***** Sentences should end with a single space
Welcome to 2017.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

***** Whitespace must be purged
I can't think of scenario in which I wanted extraneous whitespace,
so let's just destroy it.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :init
    (add-hook 'before-save-hook 'whitespace-cleanup))
#+END_SRC
***** Spaces, not tabs
Also default tab-width and good old-fashioned 80 columns. Fite me
irl.
#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 80)
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
#+END_SRC
*** Functionality
**** Discoverability
=which-key= is really cool. Muscle memory is no substitute for a
reminder now and then.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish ""
    :config
    (progn
      (which-key-mode)
      (which-key-setup-side-window-right-bottom))
    :quelpa (:upgrade t))
#+END_SRC
* Helpers
** Useful Macros
*** Interactively invoke a function with arguments
#+BEGIN_SRC emacs-lisp
  (defmacro ε (f &rest args)
    `(lambda (&rest rest)
       (interactive)
       (apply ,f ,@args rest)))
#+END_SRC
** Useful Functions
*** Globally bind a key to a function
#+BEGIN_SRC emacs-lisp
  (defun π (key f)
    (global-set-key (kbd key) f))
#+END_SRC
* Modal Editing
I have been an Evil user for several years. From a health perspective, modal
interactions are certainly better than CUA and Emacs-style chording,
especially during longer refactoring sessions where the primary interaction is
editing text rather than typing.

That said, I'm moderately convinced that the changes that Evil makes to the
interaction model of Emacs may be a bit of an overreach, and may not reflect
what I actually want out of modal editing. My reliance on Evil may very well
just be an artifact of my long use of Vim. To that end, modal features will be
implemented here with Mark Karpov's [[https://github.com/mrkkrp/modalka][=modalka=]]. This provides no features out
of the box, but allows the user to customize their modal experience as they
see fit.

This sounds like a hassle, to be honest, but a great deal of the Evil setup
process is either finding and learning a set of Evil bindings provided by a
compatibility package or setting up one's own bindings, anyway, so this isn't
really that different in the long run.

For the sake of completeness, these bindings will be defined according to the
content in the extremely educational [[https://www.masteringemacs.org][Mastering Emacs]] by Mickey Petersen.


* Useful Features
** Narrow to region
[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Narrowing.html][Narrow to region]] is a really neat feature. It allows us to define an active
region and have all commands within that region only affect that space. This
is especially good for text replacement, refactoring, and other tasks where
we don't necessarily want to alter the entire file. It's a bit unintuitive at
first, so it's disabled by default. This will enable the functionality.
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+END_SRC
** PDF viewing
[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html][DocView]] is one of the nicer PDF viewers, especially if you tend to live in
Emacs a lot. Split view is especially useful for complex documents.
#+BEGIN_SRC emacs-lisp
  (setq doc-view-continuous t)
#+END_SRC
* Look and Feel
** Appearance
*** Theme
=moe-theme= is an old-favorite.

#+BEGIN_SRC emacs-lisp
  (use-package moe-theme
    :defer t
    :init
    (use-package moe-theme-switcher)
    :quelpa (:upgrade t))
#+END_SRC
*** Font
~ TYPOGRAPHY ~

We begin with a macro I stole from somewhere for creating font classes.
#+BEGIN_SRC emacs-lisp
  (defmacro evo|define-font-class (name &rest alternates)
    (let ((alts (cl-gensym)) (sel (cl-gensym)))
      `(lexical-let* ((,alts ',alternates)
                      (,sel  (or (when (functionp 'x-family-fonts)
                                   (cl-find-if 'x-family-fonts ,alts))
                                 (car (last ,alts)))))
                     (defun ,name (&optional size)
                       (or (and size (format "%s-%d" ,sel size))
                           ,sel)))))
#+END_SRC

Then we'll set up default font stacks for fixed- and variable-pitch fonts.

#+BEGIN_SRC emacs-lisp
  (evo|define-font-class fpfont "PragmataPro")
  (evo|define-font-class vpfont
                         "Akzidenz-Grotesk Pro"
                         "Avenir"
                         "Noto Sans"
                         "Dejavu Sans"
                         "Sans Serif")
#+END_SRC

Then we set up fonts according to our window system.

#+BEGIN_SRC emacs-lisp
  (use-package frame
    :commands fpfont
    :init
    (setq window-system-default-frame-alist
          `((ns  . ((font . ,(fpfont 14))))
            (mac . ((font . ,(fpfont 14))))
            (w32 . ((font . ,(fpfont 14))))
            (x   . ((font . ,(fpfont 14)))))))
#+END_SRC

And now force those fonts on frames always.

#+BEGIN_SRC emacs-lisp
  (use-package faces
    :commands (fpfont vpfont)
    :init
    (progn
      (set-face-attribute 'fixed-pitch nil :family (fpfont))
      (set-face-attribute 'variable-pitch nil :family (vpfont) :height 1.0)))
#+END_SRC

Fixed width is great for code, but there's a reasonable argument to be made
that variable width is nicer for reading.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'variable-pitch-mode)
  
  (add-hook 'Info-mode-hook 'variable-pitch-mode)
#+END_SRC

Org is a little more complex. I want fixed-width in code and tables, but not for normal text.

#+BEGIN_SRC emacs-lisp
  (defun evo/adjoin-to-list-or-symbol (element list-or-symbol)
    (let ((list (if (not (listp list-or-symbol))
                    (list list-or-symbol)
                  list-or-symbol)))
      (require 'cl-lib)
      (cl-adjoin element list)))
  
  (use-package org
    :commands -each
    :config
    (-each (list 'org-code 'org-block 'org-table)
      (lambda (face)
        (set-face-attribute
         face nil
         :inherit
         (evo/adjoin-to-list-or-symbol
          'fixed-pitch
          (face-attribute face :inherit))))))
#+END_SRC

Frames are pretty picky, in my experience, so this just takes our parameters
and reapplies them. Show Emacs you mean business.

#+BEGIN_SRC emacs-lisp
  (defun evo/setup-frame (frame)
    "Reapplies frame parameters from `default-frame-alist' and
  `window-system-default-frame-alist'. This is useful while
  tweaking and to setup the initial frame."
    (let* ((type (framep-on-display frame))
           (special (assq type window-system-default-frame-alist)))
      (dolist (p default-frame-alist)
        (set-frame-parameter frame (car p) (cdr p)))
      (when special
        (dolist (p (cdr special))
          (set-frame-parameter frame (car p) (cdr p))))))
  
  (defun evo/setup-all-frames (&optional frame)
    (dolist (frame (frame-list))
      (evo/setup-frame frame)))
  
  (use-package frame
    :config
    (add-to-list 'after-make-frame-functions 'evo/setup-all-frames))
  
  (evo/setup-all-frames)
#+END_SRC
* Work
** Programming
*** Languages
**** APL
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (use-package gnu-apl-mode
      :quelpa
      ((gnu-apl-mode
       :fetcher github
       :repo "lokedhs/gnu-apl-mode")
       :upgrade t)))
#+END_SRC
** Debugging
We set [[https://www.gnu.org/software/gdb/][=gdb=]] up as a mutlti-windowed debugger.
#+BEGIN_SRC emacs-lisp
  (setq gdb-many-windows t
        gdb-show-main t)
#+END_SRC
** Diffing
[[https://www.gnu.org/software/emacs/manual/html_node/ediff/][=ediff=]] is my diff and merge tool of choice, and I prefer the diff to be
displayed in a single window, rather than in multiple frames.
#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

** Tramp
I just started getting the hang of [[https://www.emacswiki.org/emacs/TrampMode][Tramp]] for remote editing, and I've found
the experience quite gratifying. I do everything over SSH, so we'll inform
Tramp that we really want that by default.
#+BEGIN_SRC emacs-lisp
  (setq tramp-default-method "ssh"
        tramp-backup-directory-alist backup-directory-alist
        tramp-ssh-controlmaster-options "ssh")
#+END_SRC
